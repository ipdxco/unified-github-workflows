name: Create PRs

on:
  workflow_dispatch:
    inputs:
      branch:
        description: "Branch from which to merge PRs"
        required: false
  # schedule:
  #   - cron: "0 0 * * *" # https://crontab.guru/every-day

jobs:
  dispatch:
    name: Create PRs
    runs-on: ubuntu-latest
    steps:
      - name: Create PRs
        env:
          BRANCH: ${{ github.event.inputs.branch }}
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.UCI_GITHUB_TOKEN }}
          retries: 0
          script: |
            const request = async function(req, opts) {
              try {
                return await req(opts)
              } catch(err) {
                opts.request.retries = (opts.request.retries || 0) + 1
                if (err.status === 403) {
                  if (err.response.headers['x-ratelimit-remaining'] === '0') {
                    const retryAfter = err.response.headers['x-ratelimit-reset'] - Math.floor(Date.now() / 1000) || 1
                    core.info(`Rate limit exceeded, retrying in ${retryAfter} seconds`)
                    await new Promise(resolve => setTimeout(resolve, retryAfter * 1000))
                    return request(req, opts)
                  }
                  if (err.message.toLowerCase().includes('secondary rate limit')) {
                    const retryAfter = Math.pow(2, opts.request.retries)
                    core.info(`Secondary rate limit exceeded, retrying in ${retryAfter} seconds`)
                    await new Promise(resolve => setTimeout(resolve, retryAfter * 1000))
                    return request(req, opts)
                  }
                }
                throw err
              }
            }
            github.hook.wrap('request', request)

            core.info(`Looking for repositories the user has direct access to`)
            const items = await github.paginate(github.rest.repos.listForAuthenticatedUser, {
              affiliation: 'collaborator'
            })
            core.info(`Filtering out the repositories without unmerged branches`)
            const repoBranches = []
            for (const item of items) {
              if (item.archived) {
                core.info(`Skipping archived repository ${item.html_url}`)
                continue
              }
              core.info(`Looking for matching branches for ${item.html_url}`)
              const branches = (await github.paginate(github.rest.repos.listBranches, {
                owner: item.owner.login,
                repo: item.name
              })).filter(branch => {
                if (process.env.BRANCH) {
                  return branch.name == process.env.BRANCH
                } else {
                  return branch.name.startsWith('uci/')
                }
              })
              for (const branch of branches) {
                core.info(`Checking if ${branch.html_url} requires a PR to be created`)
                const {data: compare} = await github.rest.repos.compareCommitsWithBasehead({
                  owner: item.owner.login,
                  repo: item.name,
                  basehead: `${item.default_branch}...${branch.name}`
                })
                if (compare.status == 'ahead') {
                  core.info(`PR for ${branch.html_url} should exist`)
                } else {
                  core.info(`PR for ${branch.html_url} is not needed`)
                  continue
                }
                const {data: pulls} = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                  owner: item.owner.login,
                  repo: item.name,
                  commit_sha: branch.commit.sha
                })
                if (pulls.length == 0) {
                  core.info(`PR for ${branch.html_url} should be created`)
                  repoBranches.push({repo: item, branch})
                } else {
                  core.info(`PR for ${branch.html_url} already exists`)
                }
              }
            }
            core.info(`Attempting to create the PRs`)
            const failed = []
            for (const {repo, branch} of repoBranches) {
              core.info(`Creating PR for ${branch.html_url}`)
              try {
                const pr = await octokit.rest.pulls.create({
                  owner: repo.owner.login,
                  repo: repo.name,
                  head: branch.name,
                  base: repo.default_branch
                })
                core.info(`${pr.html_url} created successfully`)
              } catch(error) {
                core.error(`Couldn't create a PR for ${branch.html_url}, got: ${error}`)
                failed.push({repo, branch})
              }
            }
            if (failed.length != 0) {
              throw new Error(`Failed to create ${failed.length} PRs`)
            }
